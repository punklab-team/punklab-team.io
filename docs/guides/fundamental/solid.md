# SOLID

Если эти рекомендации будут приняты во внимание при разработке объектно-ориентированного программного обеспечения, код станет менее сложным, риск поломок снизится, взаимодействие между различными объектами улучшится, а код станет более гибким, читабельным и управляемым.

## **Single Responsibility Principle (SRP)**

> Есть только одна причина, которая приводит к смене класса.
> 

Один класс должен решать только одну задачу. У него может быть несколько методов, но их следует использовать только для решения общей проблемы. Все методы и свойства должны служить одной и той же цели. Если класс имеет несколько назначений, его необходимо разделить на отдельные классы. Этот принцип применим не только к классам, но и к модулям, файловым структурам и папкам.

По большому счету, вы можете соблюдать этот принцип только в том случае, если принимаете во внимание поток изменений в требованиях, поскольку не всегда однозначно ясно, насколько та или иная задача является общей.

## **Open-closed Principle (OCP)**

> Программные объекты должны быть открыты для расширения, но закрыты для модификации.
> 

Принцип гласит, что программные объекты (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. Это означает, что эти объекты могут изменять свое поведение без изменения исходного кода.
В этом контексте открытость для расширения - это возможность добавлять новое поведение для класса, модуля или функции, если это необходимо, а закрытость для изменений - это запрет на изменение исходного кода программных сущностей.

Следование этому принципу гарантирует, что класс определен достаточно для того, чтобы делать то, что он должен делать. Добавление любых дополнительных функций может быть реализовано путем создания новых сущностей, которые расширяют возможности существующего класса и добавляют к себе дополнительные функции. Таким образом, можно предотвратить частые и тривиальные изменения в хорошо зарекомендовавшем себя классе низкого уровня.

## **Liskov Substitution Principle (LSP)**

> Подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.
> 

Это означает, что любая реализация абстракции (интерфейса) должна быть взаимозаменяемой в любом месте, где эта абстракция принята. Фактически, когда мы используем интерфейсы в коде, мы используем контракт не только для входных данных, получаемых интерфейсом, но и для выходных данных, возвращаемых различными классами, реализующими этот интерфейс. В обоих случаях данные должны быть одного типа.

## **Interface Segregation Principle (ISP)**

> Вы не можете заставить клиента реализовать интерфейс, который он не использует.
> 

Это означает, что вам нужно разбить интерфейсы на более мелкие, которые лучше отвечают конкретным потребностям клиентов.
Как и в случае с принципом единоличной ответственности, целью принципа разделения интерфейсов является минимизация побочных эффектов и повторений путем разделения программного обеспечения на независимые части.

## **Dependency Inversion Principle (DIP)**

> Высокоуровневые модули не должны зависеть от низкоуровневых. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
> 

Проще говоря: зависите от абстракций, а не от чего-то конкретного.

Применяя этот принцип, некоторые модули можно легко заменить другими, просто изменив модуль зависимостей, и тогда никакие изменения в низкоуровневом модуле не повлияют на высокоуровневый.